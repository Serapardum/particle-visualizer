<!DOCTYPE html>
<html>
<head>
  <title>Particle Field Visualizer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: black;
      color: white;
      font-family: sans-serif;
      text-align: center;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      display: block;
      background: black;
      z-index: 0;
    }

    button {
      margin: 5px;
      padding: 10px;
      font-size: 16px;
      position: relative;
      z-index: 2;
    }

    #controls, #label, h2 {
      position: relative;
      z-index: 2;
    }
    
    #left-controls {
      position: absolute;
      bottom: 20px;
      left: 10px;
      display: flex;
      flex-direction: column;
      z-index: 2;
    }
    
    #left-controls button {
      margin: 4px 0;
    }

    #ui-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      position: relative;
      z-index: 2;
    }

    #ui-wrapper > div,
    #ui-wrapper > h2 {
      margin-bottom: 10px;
    }

    #controls {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    #zoom {
      direction: rtl;
    }
  </style>
</head>
<body>
    <div id="ui-wrapper">
      <h2>Particle Field Visualizer</h2>
    
      <div id="label">Scene 0 Active</div>
    
      <div id="controls">
        <label for="zoom">Zoom: <span id="zoomValue">200</span></label>
        <input type="range" id="zoom" min="10" max="300" step="1" value="200"><br>
        <button id="colorToggleBtn" onclick="toggleColor()" style="display: none; margin-top: 10px;">Color Theory</button>
      </div>
    </div>
    
    <!-- NEW: Left-aligned floating buttons -->
    <div id="left-controls">
      <button id="toggleColorModeBtn" onclick="toggleColorMode()">Toggle Color Mode</button>
      <button id="toggleResolutionBtn" onclick="toggleResolutionMode()">Toggle Resolution Mode</button>
      <input type="range" id="separationSlider" min="1" max="100" step="1" value="15">
      <label id="separationLabel">Separation: 15</label>
    </div>    
    <canvas id="canvas"></canvas>

  <script>
    // CONSTANTS //
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let width, height, centerX, centerY;
    let scene = 0;
    let zoomFactor = 200;
    let particleAngle = 0;
    let hadronAngle = 0;
    let colorPalette = 0;
    let offsetX = 0;
    let offsetY = 0;
    
    const zoomLabel = document.getElementById("zoomValue");
    
    // Directional field channels
    const DIR_POS_X = 0;  // +X → right  → orange
    const DIR_NEG_X = 1;  // -X → left   → blue
    const DIR_POS_Y = 2;  // +Y → up     → green
    const DIR_NEG_Y = 3;  // -Y → down   → red
    const DIR_POS_Z = 4;  // +Z → forward → yellow
    const DIR_NEG_Z = 5;  // -Z → back    → purplej
    
    let zRenderMode = "slice";     // "slice" or "surface"
        
    // 3D buffer dimensions for the gluon field
    let size3DX = 0, size3DY = 0, size3DZ = 0;
    let buffer3DDir = null;

    let colorMode = "subtractive";
    function toggleColorMode() {
      colorMode = (colorMode === "subtractive") ? "additive" : "subtractive";
      updateColorModeLabel();
    }
    function updateColorModeLabel() {
      const btn = document.getElementById("toggleColorModeBtn");
      if (btn) btn.innerText = "Color Mode: " + colorMode;
    }
        
    let resolution = "medium";
    function toggleResolutionMode() {
      if ( resolution === "low") {
        resolution = "medium"
      } else if ( resolution === "medium" ) {
        resolution = "high";
      } else { 
        resolution = "low" 
      };
      
      updateResolutionLabel();
    }
    function updateResolutionLabel() {
      document.getElementById("toggleResolutionBtn").innerText = "Resolution: " + resolution;
    } 
               
    function calculate3DSizes() {
//      const V = 262144;    // 64x64x64
      const V = 262144;    // 64x64x64
      const W = canvas.width;
      const H = canvas.height;
      const D = (W + H) / 2;
    
      const k = Math.cbrt(V / (W * H * D));
    
      size3DX = Math.round(k * W);
      size3DY = Math.round(k * H);
      size3DZ = Math.round(k * D);
        
      return { size3DX, size3DY, size3DZ };
    }
   
    function bufferInit() {
      // Recalculate field dimensions based on canvas size
      ({ size3DX, size3DY, size3DZ } = calculate3DSizes());    
      
      const totalVoxels = size3DX * size3DY * size3DZ * 6;
    
      // Allocate or reset buffer
      if (!buffer3DDir || buffer3DDir.length !== totalVoxels) {
        buffer3DDir = new Float32Array(totalVoxels);
      } else {
        buffer3DDir.fill(0);
      }
    
      console.log(`Initialized 3D buffer: ${size3DX}×${size3DY}×${size3DZ} = ${totalVoxels} floats`);
    }
                 
    function emitOscillatingParticle(buffer, cx, cy, cz, t, radius) {
      const osc = Math.sin(t * 2 * Math.PI);
      const radiusInt = Math.floor(radius);
    
      for (let z = -radiusInt; z <= radiusInt; z++) {
        for (let y = -radiusInt; y <= radiusInt; y++) {
          for (let x = -radiusInt; x <= radiusInt; x++) {
            const dist = Math.sqrt(x * x + y * y + z * z);
            if (dist > radius) continue;
    
            const falloff = 1 - dist / radius;
            const alpha = falloff * falloff;
            const value = 255 * alpha * osc;
    
            const ix = cx + x;
            const iy = cy + y;
            const iz = cz + z;
    
            if (
              ix < 0 || ix >= size3DX ||
              iy < 0 || iy >= size3DY ||
              iz < 0 || iz >= size3DZ
            ) continue; 
               
            const dir = osc >= 0 ? DIR_POS_Y : DIR_NEG_Y;
            const idx = getFieldIndex(ix, iy, iz, dir);
            buffer[idx] += Math.abs(value);
          }
        }
      }
    }

    /* ====================================================================
       Colour-aware voxel-projection renderer
       ==================================================================== */
    function renderGluonField(buffer3D, ctx, offX, offY, sX, sY, opts = {})
    {
      const W = ctx.canvas.width, H = ctx.canvas.height;
    
      /* persistent ImageData buffer */
      if (!renderGluonField.img ||
          renderGluonField.img.width  !== W ||
          renderGluonField.img.height !== H)
      {
        renderGluonField.img = ctx.getImageData(0,0,W,H);
      }
      const pix = renderGluonField.img.data;
    
      /* clear */
      for (let i = 0; i < pix.length; i += 4) {
        pix[i] = pix[i+1] = pix[i+2] = 0;  pix[i+3] = 255;
      }
    
      /* options */
      const mode        = opts.mode        || "additive";   // additive | subtractive
      const resolution  = opts.resolution  || "medium";     // low | medium | high
      const threshold   = (opts.threshold !== undefined) ? opts.threshold : 50;
    
      const stopMode = (resolution === "low")  ? "first" : "peak";
      const fillMode = (resolution === "high") ? "gradient" : "block";
      const peakThreshold = 4;                 // ignore very weak peaks
    
      /* pixel writer */
      function set(px, py, r, g) {
        if (px<0||py<0||px>=W||py>=H) return;
        const i = ((py*W)+px)<<2;  pix[i]=r;  pix[i+1]=g;
      }
    
      /* ---- main XY scan ----------------------------------------------- */
      for (let vy = 0; vy < size3DY; ++vy) {
        for (let vx = 0; vx < size3DX; ++vx) {
    
          let bestZ = 0, bestR = 0, bestG = 0, bestScore = -1;
    
          /* ---- Z scan -------------------------------------------------- */
          for (let z = 0; z < size3DZ; ++z) {
    
            /* four voxel corners */
            const r00 = buffer3D[getFieldIndex(vx  ,vy  ,z,DIR_NEG_Y)];
            const g00 = buffer3D[getFieldIndex(vx  ,vy  ,z,DIR_POS_Y)];
            const r10 = buffer3D[getFieldIndex(vx+1,vy  ,z,DIR_NEG_Y)];
            const g10 = buffer3D[getFieldIndex(vx+1,vy  ,z,DIR_POS_Y)];
            const r01 = buffer3D[getFieldIndex(vx  ,vy+1,z,DIR_NEG_Y)];
            const g01 = buffer3D[getFieldIndex(vx  ,vy+1,z,DIR_POS_Y)];
            const r11 = buffer3D[getFieldIndex(vx+1,vy+1,z,DIR_NEG_Y)];
            const g11 = buffer3D[getFieldIndex(vx+1,vy+1,z,DIR_POS_Y)];
    
            /* skip if the whole square is empty */
            if ((r00|g00|r10|g10|r01|g01|r11|g11) === 0) continue;
    
            /* centre-point bilinear */
            const rc = (r00 + r10 + r01 + r11) * 0.25;
            const gc = (g00 + g10 + g01 + g11) * 0.25;
            const score = (mode === "additive") ? (rc + gc)
                                                : Math.abs(rc - gc);
    
            if (stopMode === "first") {
              if (score > threshold) {           // first bright slice → take & quit
                bestZ = z; bestR = rc; bestG = gc; bestScore = score;
                break;
              }
            } else {                             // "peak"
              if (score > bestScore) {
                bestScore = score;
                bestZ = z; bestR = rc; bestG = gc;
              } else if (bestScore >= peakThreshold && score < bestScore) {
                break;                           // passed the peak → early exit
              }
            }
          } /* Z loop */
    
          /* skip column if nothing good found */
          if (bestScore < ((stopMode === "first") ? threshold : peakThreshold)) continue;
    
          /* display colours */
          let dispR = bestR, dispG = bestG;
          if (mode === "subtractive") {
            const d = Math.abs(bestR - bestG);
            if (bestR >= bestG) { dispR = d; dispG = 0; }
            else                { dispR = 0; dispG = d; }
          }
    
          const px0 = Math.floor(offX + vx * sX);
          const py0 = Math.floor(offY + vy * sY);
    
          /* -------------- render ---------------------------------------- */
          if (fillMode === "block") {
            for (let dy=0; dy<=sY; ++dy)
              for (let dx=0; dx<=sX; ++dx)
                set(px0+dx, py0+dy, dispR|0, dispG|0);
    
          } else { /* gradient (high) */
            const r00 = buffer3D[getFieldIndex(vx  ,vy  ,bestZ,DIR_NEG_Y)];
            const g00 = buffer3D[getFieldIndex(vx  ,vy  ,bestZ,DIR_POS_Y)];
            const r10 = buffer3D[getFieldIndex(vx+1,vy  ,bestZ,DIR_NEG_Y)];
            const g10 = buffer3D[getFieldIndex(vx+1,vy  ,bestZ,DIR_POS_Y)];
            const r01 = buffer3D[getFieldIndex(vx  ,vy+1,bestZ,DIR_NEG_Y)];
            const g01 = buffer3D[getFieldIndex(vx  ,vy+1,bestZ,DIR_POS_Y)];
            const r11 = buffer3D[getFieldIndex(vx+1,vy+1,bestZ,DIR_NEG_Y)];
            const g11 = buffer3D[getFieldIndex(vx+1,vy+1,bestZ,DIR_POS_Y)];
    
            for (let dy=0; dy<=sY; ++dy) {
              const fy = dy / sY;
              const lR = r00 + fy*(r01-r00), lG = g00 + fy*(g01-g00);
              const rR = r10 + fy*(r11-r10), rG = g10 + fy*(g11-g10);
    
              for (let dx=0; dx<=sX; ++dx) {
                const fx = dx / sX;
                let pR = lR + fx*(rR-lR);
                let pG = lG + fx*(rG-lG);
    
                if (mode === "subtractive") {
                  const d = Math.abs(pR - pG);
                  if (pR >= pG) { pR = d; pG = 0; } else { pR = 0; pG = d; }
                }
                if ((pR|pG) === 0 && bestScore > 0) { pR = pG = 1; } // dim fallback
                set(px0+dx, py0+dy, pR|0, pG|0);
              }
            }
          }
        }
      }
      ctx.putImageData(renderGluonField.img, 0, 0);
    }
    
    function getFieldIndex(x, y, z, dir) {
      return ((y * size3DZ + z) * size3DX + x) * 6 + dir;
    } 
    
    /* ────────────────────────────────────────────────────────────────
       Net inward-push force at a voxel surrounded by an outward field
       Returns a gluon-space vector { fx, fy, fz }
       ---------------------------------------------------------------- */
    function sampleNetForce3D(cx, cy, cz, R = 20) {
      let fx = 0, fy = 0, fz = 0;
    
      for (let dz = -R; dz <= R; dz++) {
        const z = cz + dz;
        if (z < 0 || z >= size3DZ) continue;
    
        for (let dy = -R; dy <= R; dy++) {
          const y = cy + dy;
          if (y < 0 || y >= size3DY) continue;
    
          for (let dx = -R; dx <= R; dx++) {
            const x = cx + dx;
            if (x < 0 || x >= size3DX) continue;
            if (dx === 0 && dy === 0 && dz === 0) continue;      // skip center
    
            // use one channel (e.g. DIR_POS_Y) as magnitude proxy
            const val = buffer3DDir[getFieldIndex(x, y, z, DIR_POS_Y)];
            if (val < 1) continue;
    
            const dist = Math.hypot(dx, dy, dz);
            const scale = -(val / dist);    // negative → toward center
            fx += dx * scale;
            fy += dy * scale;
            fz += dz * scale;
          }
        }
      }
      return { fx, fy, fz };
    }    
    
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      width = canvas.width;
      height = canvas.height;
      centerX = width / 2;
      centerY = height / 2;
      draw();
    }
    
    function drawArrow(x1, y1, x2, y2) {
      const headlen = 10;
      const dx = x2 - x1;
      const dy = y2 - y1;
      const angle = Math.atan2(dy, dx);
    
      ctx.strokeStyle = "white";
      ctx.fillStyle = "white";
      ctx.lineWidth = 2;
      ctx.setLineDash([]);
    
      // Main shaft
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    
      // Arrowhead
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6),
                 y2 - headlen * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6),
                 y2 - headlen * Math.sin(angle + Math.PI / 6));
      ctx.closePath();
      ctx.fill();
    }

    function sceneMain() {
      try {
        bufferInit();
    
        const timePhase = performance.now() / 4000;
        const zoomScale = zoomFactor / 100;
    
        const gluonCenterX = Math.floor(size3DX / 2);
        const gluonCenterY = Math.floor(size3DY / 2);
        const gluonCenterZ = Math.floor(size3DZ / 2);

        let pairCenterX = 0;
             
        const fieldRadius = 10 * zoomScale;
        const orbitRadius = Math.round(5  * zoomScale);
        const triangleRadius = Math.round(40 * zoomScale);
    
        const ZOOM_PARTICLE  = 175;
        const ZOOM_HADRON = 70;
        
        /* ------------------------------------------------------------------ */
        /* 1. SINGLE-PARTICLE VIEW                                            */
        /* ------------------------------------------------------------------ */
        if (zoomFactor > ZOOM_PARTICLE) {
          // Emit 3D directional oscillation for full simulation
          emitOscillatingParticle( buffer3DDir, gluonCenterX, gluonCenterY, gluonCenterZ, timePhase, fieldRadius);
                  
        /* ------------------------------------------------------------------ */
        /* 2. HADRON-PAIR VIEW   (zoom 250 → 70)                              */
        /* ------------------------------------------------------------------ */
        } else if (zoomFactor > ZOOM_HADRON ) {
          const zoomRange  = ZOOM_PARTICLE - ZOOM_HADRON;
          const progress01 = (zoomFactor - ZOOM_HADRON) / zoomRange; // 0-→1
    
          pairCenterX   = gluonCenterX + Math.round(orbitRadius * progress01);
    
          const angle = timePhase * 2 * Math.PI;
          const dx = Math.cos(angle) * orbitRadius;
          const dy = Math.sin(angle) * orbitRadius;
    
          emitOscillatingParticle(
            buffer3DDir,
            Math.round(pairCenterX + dx),
            Math.round(gluonCenterY   + dy),
            gluonCenterZ, timePhase, fieldRadius
          );
    
          emitOscillatingParticle(
            buffer3DDir,
            Math.round(pairCenterX - dx),
            Math.round(gluonCenterY   - dy),
            gluonCenterZ, timePhase + 0.5, fieldRadius
          );
    
        /* ------------------------------------------------------------------ */
        /* 3. BARYON VIEW (zoom ≤ 70) — camera glued to hadron 0, with phase  */
        /* ------------------------------------------------------------------ */
        } else {
        
          const hLock = 2;                                             // lock to hadron 2
          const hAngle = particleAngle + hLock * (2 * Math.PI / 3) - Math.PI / 3;
          const hXoff  = Math.cos(hAngle) * triangleRadius;
          const hYoff  = Math.sin(hAngle) * triangleRadius;
        
          const t          = zoomFactor / 70;
          const camCenterX = Math.round(gluonCenterX + hXoff * t);
          const camCenterY = Math.round(gluonCenterY + hYoff * t);
          const camCenterZ = gluonCenterZ;
        
          particleAngle += 0.02;
          hadronAngle   += 0.05;
        
          for (let h = 0; h < 3; h++) {
            const ang   = particleAngle + h * (2 * Math.PI / 3);
            const triX  = Math.cos(ang) * triangleRadius;
            const triY  = Math.sin(ang) * triangleRadius;
        
            const hadronCX = Math.round(camCenterX + triX);
            const hadronCY = Math.round(camCenterY + triY);
            const hadronCZ = camCenterZ;
        
            const a = hadronAngle;
            let x1, y1, z1, x2, y2, z2;
        
            if (h === 0) {           // XY
              x1 = hadronCX + Math.round(Math.cos(a) * orbitRadius);
              y1 = hadronCY + Math.round(Math.sin(a) * orbitRadius);
              z1 = hadronCZ;
        
              x2 = hadronCX - Math.round(Math.cos(a) * orbitRadius);
              y2 = hadronCY - Math.round(Math.sin(a) * orbitRadius);
              z2 = hadronCZ;
        
            } else if (h === 1) {    // YZ
              x1 = hadronCX;
              y1 = hadronCY + Math.round(Math.cos(a) * orbitRadius);
              z1 = hadronCZ + Math.round(Math.sin(a) * orbitRadius);
        
              x2 = hadronCX;
              y2 = hadronCY - Math.round(Math.cos(a) * orbitRadius);
              z2 = hadronCZ - Math.round(Math.sin(a) * orbitRadius);
        
            } else {                 // XZ  (h === 2)
              x1 = hadronCX + Math.round(Math.cos(a) * orbitRadius);
              y1 = hadronCY;
              z1 = hadronCZ + Math.round(Math.sin(a) * orbitRadius);
        
              x2 = hadronCX - Math.round(Math.cos(a) * orbitRadius);
              y2 = hadronCY;
              z2 = hadronCZ - Math.round(Math.sin(a) * orbitRadius);
            }
        
            emitOscillatingParticle(buffer3DDir, x1, y1, z1, timePhase,       fieldRadius);
            emitOscillatingParticle(buffer3DDir, x2, y2, z2, timePhase + 0.5, fieldRadius);
          }
        }
        
        /* ------------------------------------------------------------------ */
        /* Render buffer to canvas                                            */
        /* ------------------------------------------------------------------ */
        const scaleX = canvas.width  / size3DX;
        const scaleY = canvas.height / size3DY;
    
        renderGluonField(buffer3DDir, ctx, 0, 0, scaleX, scaleY, { mode: colorMode, resolution: resolution });
    
        /* UI label update */
        const label = document.getElementById("label");
        if (label) {
          label.innerText =
            zoomFactor > 250 ? "Scene: Particle" :
            zoomFactor >  70 ? "Scene: Hadron Pair" :
                               "Scene: Baryon Trio";
        }
        
        if ( zoomFactor > ZOOM_PARTICLE ) {
          
          ctx.fillStyle = "white";
          
          ctx.fillText("centerX: " + centerX, 20, 100 );
          ctx.fillText("centerY:" +  centerY, 20, 120 );
        
          // Downward arrow from left, label "Particle"
          drawArrow(centerX - 80, centerY, centerX, centerY);
          ctx.fillText("Particle", centerX - 110, centerY + 20);
          ctx.fillText("Fluctuates at f", centerX - 110, centerY + 40);
          
          // Dotted velocity arrow → right
          ctx.setLineDash([5, 5]);
          drawArrow(centerX, centerY, centerX + 80, centerY);
          ctx.setLineDash([]);
          ctx.fillText("V", centerX + 85, centerY - 5);
        
          // Diagonal arrow up-right labeled "Propagates at C"
          drawArrow(centerX, centerY, centerX + 70, centerY - 70);
          ctx.fillText("Propagates at C", centerX + 75, centerY - 75);
        
          // Higgs field arrows
          const hx = centerX + 100;
          const hy = centerY + 100;
          drawArrow(hx, hy, hx, hy - 60);         // upward
          drawArrow(hx, hy, hx + 45, hy + 45);    // down-right
          drawArrow(hx, hy, hx - 45, hy + 45);    // down-left
          ctx.fillText("Higgs field", hx + 50, hy - 10);
          
        } else if ( zoomFactor > ZOOM_HADRON ) {
          drawArrow(pairCenterX * scaleX, centerY - 100, pairCenterX * scaleX, centerY);
          ctx.fillStyle = "white";
          ctx.fillText("Opposing field forces", pairCenterX * scaleX + 10, centerY - 70);
          ctx.fillText("negate each other", pairCenterX * scaleX + 10, centerY - 50);
          ctx.fillText("Unequal forces cause particles to move toward lesser force", centerX - 120, centerY + 100);
          ctx.fillText("This causes particles to be pushed toward each other by the forces in the Higgs Field", centerX - 175, centerY + 130);
          ctx.fillText("This produces a hadron of two particles opposed in phase in a stable 2 body orbit", centerX - 175, centerY + 160);
            
        }
    
        ctx.fillStyle = "white";
        ctx.fillText("Scene: Main",                 20, 20);
        ctx.fillText("Zoom scale: " + zoomScale.toFixed(2) + "×", 20, 40);
        ctx.fillText("Color Mode: " + colorMode,   20, 60);
        ctx.fillText("Resolution: " + resolution,  20, 80);
    
      } catch (e) {
        const log = document.getElementById("errorLog");
        if (log) log.innerText = "sceneMain ERROR:\n" + e.message + "\n" + e.stack;
      }
    }
      
    function showDebug(x, y, gx, gy, mag) {
      let logDiv = document.getElementById("log");
      if (!logDiv) {
        logDiv = document.createElement("div");
        logDiv.id = "log";
        logDiv.style.cssText = "position:absolute;bottom:0;left:0;color:lime;font:14px monospace;";
        document.body.appendChild(logDiv);
      }
      logDiv.innerText = `x: ${x}, y: ${y}, gx: ${gx.toFixed(2)}, gy: ${gy.toFixed(2)}, mag: ${mag.toFixed(2)}`;
    }

    function draw() {
      ctx.clearRect(0, 0, width, height);
      sceneMain();
      
      requestAnimationFrame(draw);
    }
    
    function toggleColor() {
      colorPalette = (colorPalette + 1) % 3;
    }

    document.getElementById("zoom").addEventListener("input", function(e) {
      zoomFactor = parseFloat(e.target.value);
      zoomLabel.textContent = zoomFactor;
    });

    window.addEventListener("load", () => {
      updateColorModeLabel();
      updateResolutionLabel();
    });
    
    document.getElementById("separationSlider").addEventListener("input", function(e) {
      document.getElementById("separationLabel").textContent = "Separation: " + e.target.value;
    });

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    draw();
    // Done
  </script>
</body>
</html>
    